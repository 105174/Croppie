// Full version of `log` that:
//  * Prevents errors on console methods when no console present.
//  * Exposes a global 'log' function that preserves line numbering and formatting.
(function () {
  var method;
  var noop = function () { };
  var methods = [
      'assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error',
      'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log',
      'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd',
      'timeStamp', 'trace', 'warn'
  ];
  var length = methods.length;
  var console = (window.console = window.console || {});
 
  while (length--) {
    method = methods[length];
 
    // Only stub undefined methods.
    if (!console[method]) {
        console[method] = noop;
    }
  }
 
 
  if (Function.prototype.bind) {
    window.log = Function.prototype.bind.call(console.log, console);
  }
  else {
    window.log = function() { 
      Function.prototype.apply.call(console.log, console, arguments);
    };
  }
})();;var Demo = (function() {

	function output(html) {
		var existing = $("#result .imagecropper-result");

		if (existing.length > 0) {
			existing.replaceWith(html);
		}
		else {
			$("#result").append(html);
		}
	}

	function init() {
		var dbgr = $("#dbgr");
		var debug = true;
		dbgr.toggle(debug);
		var cont = $("#container").imageCropper({
			viewportWidth: 150,
			viewportHeight: 200,
			debug: debug,
			update: function (cropper) {
				// log('here');
				var data = $(this).imageCropper("get");
				output($.imageCropper.generateImage(data));

				// if (debug) {
				// 	var i = $(this).find(".ic-image");
				// 	dbgr.css({
				// 		top: i.offset().top,
				// 		left: i.offset().left,
				// 		width: i.width(),
				// 		height: i.height(),
				// 		zIndex: -1
				// 	});
				// }
			}
		});
		cont.imageCropper("bind", "cat.jpg");
	}

	return {
		init: init
	};
})();;(function ($) {

  var pre = "imagecropper-";
  $.imageCropper = function (container, opts ) {
    this.$container = $(container);
    this.options = $.extend({}, $.imageCropper.defaults, opts);

    this._create();
  };

  $.imageCropper.generateImage = function (opts) {
    var coords = opts.coords;
    var div = $("<div class='imagecropper-result' />");
    var img = $("<img />").appendTo(div);
    img.css({
      left: (-1 * coords[0]),
      top: (-1 * coords[1]),
      width: opts.imgWidth,
      height: opts.imgHeight
    }).attr("src", opts.src);

    div.css({
      width: coords[2] - coords[0],
      height: coords[3] - coords[1]
    });
    return div;
  };

  $.imageCropper.canvasImage = function (opts) {
    var def = $.Deferred();
    var coords = opts.coords;
    var prom = loadImage(opts.src);
    prom.done(function (img) {
      var canvas = document.createElement("canvas");
      var tarWidth = coords[2] - coords[0];
      var tarHeight = coords[3] - coords[1];
      canvas.width = tarWidth;
      canvas.height = tarHeight;
      var context = canvas.getContext('2d');
      context.drawImage(img, coords[0], coords[1], tarWidth, tarHeight);
      def.resolve("<img src='" + canvas.toDataURL() +"' />");
    });

    return def.promise();
  };

  $.imageCropper.defaults = {
    viewportWidth: 100,
    viewportHeight: 100,
    boundaryWidth: 300,
    boundaryHeight: 300,
    customClass: '',
    update: $.noop,
    showZoom: true
  };
  
  /* Prototype Extensions */
  $.imageCropper.prototype._create = function () {
    var self = this;
    var contClass = $.trim("imagecropper-container " + self.options.customClass);
    self.$container.addClass(contClass);
    self.$boundary = $("<div class='ic-boundary' />").appendTo(self.$container).css({
      width: self.options.boundaryWidth,
      height: self.options.boundaryHeight
    });
    self.$img = $("<img class='ic-image' />").appendTo(self.$boundary);
    self.$viewport = $("<div class='ic-viewport' />").appendTo(self.$boundary).css({
      width: self.options.viewportWidth,
      height: self.options.viewportHeight
    })
    self.$overlay = $("<div class='ic-overlay' />").appendTo(self.$boundary);
    self._initDraggable();

    if (self.options.showZoom) {
      self._initializeZoom();
    }

    if (self.options.debug) {
      self.$viewport.addClass('debug');
    }
  };

  $.imageCropper.prototype._initializeZoom = function () {
    var self = this;
    var wrap = $('<div class="ic-slider-wrap" />').appendTo(self.$container);
    self.$zoomer = $('<input type="range" class="ic-slider" step="0.01" />').appendTo(wrap);

    function start () {
      self._updateCenterPoint();
    }

    function change () {
      self._onZoom({
        value: parseFloat(self.$zoomer.val())
      });
    }

    function stop () {
      var m = parseMatrix(self.$img.css('transform')),
          pos = self._getImageRect();

      self.$img.css({
        // transformOrigin: '',
        // transform: matrix(m.scale, pos.left, pos.top)
      });
    }

    self.$zoomer.on('mousedown', start);
    self.$zoomer.on('input', change);
    self.$zoomer.on('change mouseup', stop);
    
    self._currentZoom = 1;
  };

  $.imageCropper.prototype._onZoom = function (ui) {
    var self = this,
        curMatrix = parseMatrix(self.$img.css('transform'));

    self._currentZoom = ui.value;
    self.$img.css('transform', getTransformString(ui.value, curMatrix.x, curMatrix.y));
    self._updateOverlay();
    self._triggerUpdate();
  };

  $.imageCropper.prototype._getImageRect = function () {
    var imgRect = this.$img[0].getBoundingClientRect();
        // boundRect = this.$boundary[0].getBoundingClientRect();

    return imgRect; 
    // return $.extend({}, imgRect, {
    //   top: imgRect.top - boundRect.top,
    //   left: imgRect.left - boundRect.left
    // });
  };

  $.imageCropper.prototype._updateCenterPoint = function () {
    var self = this,
        scale = self._currentZoom,
        data = self.$img[0].getBoundingClientRect(),
        vpData = self.$viewport[0].getBoundingClientRect(),
        parsed = parseMatrix(self.$img.css('transform')),
        previousOrigin = self.$img.css('transform-origin').split(' '),
        pc = {
          left: parseFloat(previousOrigin[0]),
          top: parseFloat(previousOrigin[1])
        },
        top = (vpData.top - data.top) + (vpData.height / 2),
        left = (vpData.left - data.left) + (vpData.width / 2),
        center = {},
        adj = {};

    center.top = top / scale;
    center.left = left / scale;

    adj.top = (center.top - pc.top) * (1 - scale);
    adj.left = (center.left - pc.left) * (1 - scale);

    self.$img.css({
      transformOrigin: center.left + 'px ' + center.top + 'px', 
      transform: getTransformString(parsed.scale, parsed.x - adj.left, parsed.y - adj.top)
    });
  };
  
  $.imageCropper.prototype._initDraggable = function () {
    var self = this,
        $win = $(window),
        $body = $('body'),
        isDragging = false,
        cssPos = {},
        originalX,
        originalY,
        vpRect;

    function mouseDown(ev) {
      if (isDragging) return;
      isDragging = true;
      originalX = ev.pageX;
      originalY = ev.pageY;
      cssPos = parseTransform(self.$img.css('transform'));
      $win.on('mousemove.cropper', mouseMove);
      $body.css('-webkit-user-select', 'none');
      vpRect = self.$viewport[0].getBoundingClientRect();
    };

    function mouseMove (ev) {
      var deltaX = ev.pageX - originalX,
          deltaY = ev.pageY - originalY,
          imgRect = self._getImageRect(),
          top = cssPos.y + deltaY,
          left = cssPos.x + deltaX;

      if (vpRect.top > imgRect.top + deltaY && vpRect.bottom < imgRect.bottom + deltaY) {
        cssPos.y = top;
      }

      if (vpRect.left > imgRect.left + deltaX && vpRect.right < imgRect.right + deltaX) {
        cssPos.x = left;
      }

      var m = getTransformString(self._currentZoom, cssPos.x, cssPos.y);
      self.$img.css('transform', m);
      self._updateOverlay();
      originalY = ev.pageY;
      originalX = ev.pageX;
    };

    function mouseUp (ev) {
      isDragging = false;
      $win.off('mousemove.cropper');
      $body.css('-webkit-user-select', '');
      self._triggerUpdate();
    }

    self.$overlay.on('mousedown.cropper', mouseDown);
    $win.on('mouseup.cropper', mouseUp);
  };

  $.imageCropper.prototype._updateOverlay = function () {
    var self = this,
        boundRect = this.$boundary[0].getBoundingClientRect(),
        imgData = self.$img[0].getBoundingClientRect();

    self.$overlay.css({
      width: imgData.width,
      height: imgData.height,
      top: imgData.top - boundRect.top,
      left: imgData.left - boundRect.left
    });
  };

  $.imageCropper.prototype._triggerUpdate = function () {

    console.trace();
    var self = this;
    self.options.update.apply(self.$container, self);
  }

  $.imageCropper.prototype._updatePropertiesFromImage = function () {
    var self = this;
    var imgData = self._getImageRect();
    self._originalImageWidth = imgData.width;
    self._originalImageHeight = imgData.height;

    if (self.options.showZoom) {
      var minZoom = self.$boundary.width() / imgData.width;
      var maxZoom = 1.5;
      self.$zoomer.attr('min', minZoom);
      self.$zoomer.attr('max', maxZoom);
      self.$zoomer.val(1);
    }

    self._updateOverlay();
  };

  $.imageCropper.prototype.bind = function (src, cb) {
    var self = this;
    var prom = loadImage(src);
    prom.done(function () {
      self.$img.attr("src", src);
      self._updatePropertiesFromImage();
      self._triggerUpdate();
      if (cb) {
        cb();
      }
    });
  };

  $.imageCropper.prototype.get = function () {
    var self = this;
    var imgSrc = self.$img.attr('src');
    var imgData = self._getImageRect();
    var vpOff = self.$viewport.offset();
    var imgOff = self.$img.offset();
    var x1 = vpOff.left - imgOff.left;
    var y1 = vpOff.top - imgOff.top;
    var x2 = x1 + self.$viewport.width();
    var y2 = y1 + self.$viewport.height();


    return {
      src: imgSrc,
      imgWidth: imgData.width,
      imgHeight: imgData.height,
      coords: [x1, y1, x2, y2],
      zoom: self._currentZoom
    };
  };
  /* End Prototype Extensions */


  $.fn.imageCropper = function (opts) {
    var ot = typeof opts;

    if (ot === 'string') {
      var args = Array.prototype.slice.call(arguments, 1);

      if (opts === 'get') {
        var i = $(this).data('imageCropper');
        return i.get();
      }

      return this.each(function () {
        var i = $(this).data('imageCropper');
        if (!i) return;

        var method = i[opts];
        if ($.isFunction(method)) {
          method.apply(i, args);
        }
        else {
          throw 'Image Cropper ' + options + ' method not found';
        }
      });
    }
    else {
      return this.each(function () {
        var i = new $.imageCropper(this, opts);
        $(this).data('imageCropper', i);
      });
    }
  };


  /* Utilities */
  function loadImage (src) {
    var img = new Image();
    var def = $.Deferred();
    img.onload = function () {
      def.resolve(img);
    };
    img.src = src;
    return def.promise();
  }

  function num (v) {
    return parseInt(v, 10);
  }

  function parseMatrix (v) {
    var vals = v.substring(7).split(',');
    if (!vals.length || v === 'none') {
      vals = [1, 0, 0, 1, 0, 0];
    }
    return {
      scale: parseFloat(vals[0]),
      x: parseInt(vals[4], 10),
      y: parseInt(vals[5], 10)
    };
  }

  function parseTransform (v) {
    if (v.indexOf('matrix') > -1 || v.indexOf('none') > -1) {
      return parseMatrix(v);
    }

    var values = v.split(') '),
        translate = values[0].substring(10).split(','),
        scale = values[1].substring(6);

    return {
      scale: parseFloat(scale),
      x: parseFloat(translate[0]),
      y: parseFloat(translate[1])
    };
  }

  function getTransformString(scale, x, y) {
    return 'translate(' + x + 'px, ' + y + 'px) scale(' + scale + ')';
  }

  function matrix(scale, x, y) {
    return 'matrix(' + scale + ', 0, 0, ' + scale + ', ' + x + ', ' + y + ')';
  }

})($);;/* http://prismjs.com/download.html?themes=prism&languages=css+clike+javascript */
self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{};var Prism=function(){var e=/\blang(?:uage)?-(?!\*)(\w+)\b/i,t=self.Prism={util:{encode:function(e){return e instanceof n?new n(e.type,t.util.encode(e.content),e.alias):"Array"===t.util.type(e)?e.map(t.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},clone:function(e){var n=t.util.type(e);switch(n){case"Object":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=t.util.clone(e[r]));return a;case"Array":return e.slice()}return e}},languages:{extend:function(e,n){var a=t.util.clone(t.languages[e]);for(var r in n)a[r]=n[r];return a},insertBefore:function(e,n,a,r){r=r||t.languages;var i=r[e],l={};for(var o in i)if(i.hasOwnProperty(o)){if(o==n)for(var s in a)a.hasOwnProperty(s)&&(l[s]=a[s]);l[o]=i[o]}return r[e]=l},DFS:function(e,n,a){for(var r in e)e.hasOwnProperty(r)&&(n.call(e,r,e[r],a||r),"Object"===t.util.type(e[r])?t.languages.DFS(e[r],n):"Array"===t.util.type(e[r])&&t.languages.DFS(e[r],n,r))}},highlightAll:function(e,n){for(var a,r=document.querySelectorAll('code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'),i=0;a=r[i++];)t.highlightElement(a,e===!0,n)},highlightElement:function(a,r,i){for(var l,o,s=a;s&&!e.test(s.className);)s=s.parentNode;if(s&&(l=(s.className.match(e)||[,""])[1],o=t.languages[l]),o){a.className=a.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,s=a.parentNode,/pre/i.test(s.nodeName)&&(s.className=s.className.replace(e,"").replace(/\s+/g," ")+" language-"+l);var c=a.textContent;if(c){var g={element:a,language:l,grammar:o,code:c};if(t.hooks.run("before-highlight",g),r&&self.Worker){var u=new Worker(t.filename);u.onmessage=function(e){g.highlightedCode=n.stringify(JSON.parse(e.data),l),t.hooks.run("before-insert",g),g.element.innerHTML=g.highlightedCode,i&&i.call(g.element),t.hooks.run("after-highlight",g)},u.postMessage(JSON.stringify({language:g.language,code:g.code}))}else g.highlightedCode=t.highlight(g.code,g.grammar,g.language),t.hooks.run("before-insert",g),g.element.innerHTML=g.highlightedCode,i&&i.call(a),t.hooks.run("after-highlight",g)}}},highlight:function(e,a,r){var i=t.tokenize(e,a);return n.stringify(t.util.encode(i),r)},tokenize:function(e,n){var a=t.Token,r=[e],i=n.rest;if(i){for(var l in i)n[l]=i[l];delete n.rest}e:for(var l in n)if(n.hasOwnProperty(l)&&n[l]){var o=n[l];o="Array"===t.util.type(o)?o:[o];for(var s=0;s<o.length;++s){var c=o[s],g=c.inside,u=!!c.lookbehind,f=0,h=c.alias;c=c.pattern||c;for(var p=0;p<r.length;p++){var d=r[p];if(r.length>e.length)break e;if(!(d instanceof a)){c.lastIndex=0;var m=c.exec(d);if(m){u&&(f=m[1].length);var y=m.index-1+f,m=m[0].slice(f),v=m.length,k=y+v,b=d.slice(0,y+1),w=d.slice(k+1),N=[p,1];b&&N.push(b);var O=new a(l,g?t.tokenize(m,g):m,h);N.push(O),w&&N.push(w),Array.prototype.splice.apply(r,N)}}}}}return r},hooks:{all:{},add:function(e,n){var a=t.hooks.all;a[e]=a[e]||[],a[e].push(n)},run:function(e,n){var a=t.hooks.all[e];if(a&&a.length)for(var r,i=0;r=a[i++];)r(n)}}},n=t.Token=function(e,t,n){this.type=e,this.content=t,this.alias=n};if(n.stringify=function(e,a,r){if("string"==typeof e)return e;if("[object Array]"==Object.prototype.toString.call(e))return e.map(function(t){return n.stringify(t,a,e)}).join("");var i={type:e.type,content:n.stringify(e.content,a,r),tag:"span",classes:["token",e.type],attributes:{},language:a,parent:r};if("comment"==i.type&&(i.attributes.spellcheck="true"),e.alias){var l="Array"===t.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(i.classes,l)}t.hooks.run("wrap",i);var o="";for(var s in i.attributes)o+=s+'="'+(i.attributes[s]||"")+'"';return"<"+i.tag+' class="'+i.classes.join(" ")+'" '+o+">"+i.content+"</"+i.tag+">"},!self.document)return self.addEventListener?(self.addEventListener("message",function(e){var n=JSON.parse(e.data),a=n.language,r=n.code;self.postMessage(JSON.stringify(t.util.encode(t.tokenize(r,t.languages[a])))),self.close()},!1),self.Prism):self.Prism;var a=document.getElementsByTagName("script");return a=a[a.length-1],a&&(t.filename=a.src,document.addEventListener&&!a.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",t.highlightAll)),self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism);;
Prism.languages.css={comment:/\/\*[\w\W]*?\*\//g,atrule:{pattern:/@[\w-]+?.*?(;|(?=\s*{))/gi,inside:{punctuation:/[;:]/g}},url:/url\((["']?).*?\1\)/gi,selector:/[^\{\}\s][^\{\};]*(?=\s*\{)/g,property:/(\b|\B)[\w-]+(?=\s*:)/gi,string:/("|')(\\?.)*?\1/g,important:/\B!important\b/gi,punctuation:/[\{\};:]/g,"function":/[-a-z0-9]+(?=\()/gi},Prism.languages.markup&&Prism.languages.insertBefore("markup","tag",{style:{pattern:/<style[\w\W]*?>[\w\W]*?<\/style>/gi,inside:{tag:{pattern:/<style[\w\W]*?>|<\/style>/gi,inside:Prism.languages.markup.tag.inside},rest:Prism.languages.css}}});;
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\w\W]*?\*\//g,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*?(\r?\n|$)/g,lookbehind:!0}],string:/("|')(\\?.)*?\1/g,"class-name":{pattern:/((?:(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/gi,lookbehind:!0,inside:{punctuation:/(\.|\\)/}},keyword:/\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/g,"boolean":/\b(true|false)\b/g,"function":{pattern:/[a-z0-9_]+\(/gi,inside:{punctuation:/\(/}},number:/\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?)\b/g,operator:/[-+]{1,2}|!|<=?|>=?|={1,3}|&{1,2}|\|?\||\?|\*|\/|\~|\^|\%/g,ignore:/&(lt|gt|amp);/gi,punctuation:/[{}[\];(),.:]/g};;
Prism.languages.javascript=Prism.languages.extend("clike",{keyword:/\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|get|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/g,number:/\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?|NaN|-?Infinity)\b/g}),Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:/(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/g,lookbehind:!0}}),Prism.languages.markup&&Prism.languages.insertBefore("markup","tag",{script:{pattern:/<script[\w\W]*?>[\w\W]*?<\/script>/gi,inside:{tag:{pattern:/<script[\w\W]*?>|<\/script>/gi,inside:Prism.languages.markup.tag.inside},rest:Prism.languages.javascript}}});;